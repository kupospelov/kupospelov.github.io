<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Restricting access to your $HOME - Konstantin Pospelov</title>
<link rel=stylesheet href=/style.css type=text/css media=all><link rel=icon type=image/jpg href=/img/me.jpg></head><body><nav class=menu><a class=menu-item href=/>about</a>
<a class="menu-item current" href=/blog/>blog</a><hr></nav><main><article><time pubdate=pubdate>Jan 11, 2025</time><h1>Restricting access to your $HOME</h1><p>From time to time I play some (mostly older) Steam games, which implies running closed-source binaries and hoping that they will not exploit the unrestricted access to your system. This has always been a little disturbing, but fortunately there are simple ways to decrease this risk, at least when it comes to your home directory.</p><p>As far as I know, unless we talk about more complicated options like AppArmor or SELinux, there are two general approaches to limit access to your personal files in Linux. Let&rsquo;s explore them both.</p><h2 id=running-the-binary-as-another-user>Running the binary as another user</h2><p>In the pre-Wayland times I had a working setup in which my web browser was running as a different user. In this case standard Unix file access permissions could be used to prevent that user from having access to my primary user files.</p><p>I tried using a similar approach this time as well, but found out that for Wayland/XWayland the setup became more involving. You can find more details in the <a href=https://forums.gentoo.org/viewtopic-t-1133520-start-0-postdays-0-postorder-asc-highlight-.html>discussion</a> on the Gentoo forums, here I&rsquo;ll just summarize the approach, assuming the new user is <code>steam</code>.</p><h3 id=wayland>Wayland</h3><p>To run Wayland applications, the new user must have access to the Wayland socket. Your primary user owns it, but you can use <code>setfacl</code> to share it with <code>steam</code>:</p><pre tabindex=0><code>setfacl -m steam:r-x -- &#34;$XDG_RUNTIME_DIR&#34;
setfacl -m steam:rwx -- &#34;$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY&#34;
</code></pre><h3 id=xwayland>XWayland</h3><p>To share access to the X server, you can configure mcookies:</p><pre tabindex=0><code>touch ~/.Xauthority
xauth add &#34;$DISPLAY&#34; . &#34;$(mcookie)&#34;
</code></pre><p>You can list mcookies by running <code>xauth list</code>. Make sure to add the same mcookie to the <code>.Xauthority</code> of the <code>steam</code> user so that it can authenticate.</p><p>This also requires setting the <code>-auth</code> argument for <code>Xwayland</code>. For wlroots-based compositors you can set <code>WLR_XWAYLAND</code> to run a custom script that will start <code>Xwayland</code> with the <code>-auth</code> argument that points to the created <code>.Xauthority</code> file.</p><p>I found this setup a little bit too clumsy for my use case, so I decided to look into sandboxing.</p><h2 id=running-the-binary-in-a-sandbox>Running the binary in a sandbox</h2><p>The simplest option to run a sandboxed Steam would probably be Flatpak, however there are a few things I do not like about it, most of them are covered in the <a href=https://ludocode.com/blog/flatpak-is-not-the-future>Flatpak Is Not the Future</a> post. Specifically, Steam <em>already</em> uses sandboxing to replace the system libraries with its own. So, it makes little sense to use the heavy Flatpak environment, since the Steam runtime will re-mount almost everything anyway. It will not re-mount <code>$HOME</code> though, and this is what I want to fix.</p><p>As it turns out, there are at least two lightweight sandboxing options: <a href=https://github.com/netblue30/firejail>firejail</a> and <a href=https://github.com/containers/bubblewrap>bubblewrap</a>. In fact, Steam comes with its own <a href="https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/tree/main/subprojects/bubblewrap?ref_type=heads">bubblewrap</a> that it uses to prepare the runtime. I did not experiment with <code>firejail</code> much and chose <code>bubblewrap</code> as a simpler option that happened to be already installed on my system as a dependency of another package.</p><p>I came up with the following <a href=https://git.sr.ht/~kupospelov/dotfiles/tree/700f572b63a66e7eee2f708b269fac39322417e7/item/.local/bin/sandbox>wrapper</a>. Note that <code>/mnt/sandbox</code> is mounted as <code>$HOME</code>:</p><pre tabindex=0><code>exec /usr/bin/bwrap \
  --unshare-pid \
  --ro-bind /{,} \
  --dev-bind /dev{,} \
  --proc /proc \
  --tmpfs /dev/shm \
  --tmpfs /tmp \
  --bind &#34;$XDG_RUNTIME_DIR&#34;{,} \
  --bind /mnt/sandbox &#34;$HOME&#34; \
  --ro-bind &#34;$HOME/.local/bin&#34;{,} \
  --ro-bind &#34;$HOME/.Xauthority&#34;{,} \
  --ro-bind /tmp/.X11-unix/X0{,} \
  &#34;$@&#34;
</code></pre><p>Compared to the previous approach, I obviously do not need to share anything, since the user is the same, and this simplifies the setup quite a bit.</p><p>In terms of performance, I did not notice any issues. I suspect that the sandbox may even be faster in some cases, since my home directory is encrypted and <code>/mnt/sandbox</code> is not, but I did not really measure that.</p></article></main><footer><hr><p>The content is licensed under <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a>.</p><br></footer></body></html>